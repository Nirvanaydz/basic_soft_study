#### 1、volatile的详解
#### 2、synchronized的实现原理和应用
- Java中每个对象都可以作为锁
    + 普通方法，锁对象就是当前实例对象
    + 静态同步方法，锁是当前类的class对象
    + 同步方法块，锁是synchronized括号中配置的对象
- 访问一个同步代码块时，必须先获取锁对象，在正常退出或者抛出异常时必须释放锁
- 使用的是一组进入和退出的指令
    + monitor enter
    + monitor exit
#### 3、Java的对象头中存储了什么
- synchronized使用的锁时存储在对象头中的
- 对象头
    + 对象不是一个数组时
        - mark word -- 存储对象的hashcode和锁信息
        - class metadata address -- 存储 到对象类型数据 的指针
    + 对象是一个数组时
        - 多出一个存储
        - array length -- 数组的长度
- 无锁状态：
    + 32位： 对象的hashcode（25bit）｜对象的分代年龄（4bit）｜是否是偏向锁-0（1bit）｜锁标志位-01（2bit）
    + 64为： unused（24bit）｜对象的hashcode（31bit）｜cms-free（1bit）｜对象的分代年龄（4bit）｜是否是偏向锁-0（1bit）｜锁标志位-01（2bit）
- 偏向锁状态：
    + 32位： 线程id+epoch｜分代年龄｜是否偏向锁-1｜锁标志位-01
    + 64位： threadId（54bit）+epoch（2bit）｜cms-free｜分代年龄｜是否偏向锁-1｜锁标志位-01
- 轻量级锁：
    + 32位：指向栈中锁记录的指针｜锁标志位-00
- 重量级锁：
    + 32位：指向互斥量（重量级锁）的指针｜锁标志位-10
- gc标记时：空｜锁标志位-11
#### 4、锁的升级和对比
- 无锁--》偏向锁--》轻量级锁--》重量级锁
- 偏向锁的使用和撤销
    + 不存在多线程竞争，总是由一个线程多次获得时，为了降低锁的代价引入了偏向锁
    + 线程访问同步代码块且获取锁时，
    + 在对象头和栈帧中的锁记录中存储锁偏向的线程ID
    + 后续此线程再进入和退出代码块时不需要进行cas加锁和解锁
    + 需要测试一下对象头中的mark word中存储的线程id是否和当前线程一致
        - 测试成功则获取锁成功
        - 测试失败，那么测试当前对象头中的锁状态，为1时-说明当前是偏向锁，启用cas竞争锁