### 一、运行时区域
#### 1.1、程序计数器 program counter register
- 可以看作当前线程执行的代码的字节码的行号
- 为了程序切换后能恢复到正确的位置，每个线程都需要有一个独立的程序计数器，线程私有的内存
#### 1.2、Java虚拟机栈 Java virtual machine stack 为虚拟机执行java方法（字节码）提供服务
- 线程私有，生命周期和线程同步
- 线程中每个方法被执行时都会同步创建一个栈帧--stack frame
    + 栈帧中存储了什么
        - 局部变量表
        - 操作数帧
        - 动态链接--？
        - 方法的退出方式
            + 正常退出方式
            + 抛出异常的方式
- 每一个方法被调用直至执行完毕，就对应者一个栈帧在虚拟机中的从入栈到出栈的过程
- 引申--》局部变量表
    + 存储了什么
        - 基本数据类型
        - 对象引用（reference类型，不等同与对象本身，句柄式引用和直接引用）
            + 指向对象起始地址的引用指针
            + 也可能是代表对象的句柄或者其他与此对象相关的位置
        - returnAddress类型（指向了一条字节码指令的地址）
    + 如何存储
        - slot 槽位存储
        - 64位数据类型 long和double占用两个，其余变量占用一个slot槽位
- 请求创建的栈的深度大于虚拟机允许的栈深度，且不允许动态扩展栈帧时，抛出stack overflow Error 异常
- 当虚拟机支持扩容时，栈扩展无法申请到足够的内存空间，抛出 outOfMemoryError
#### 1.3、本地方法栈 native method stacks 虚拟机使用本地方法提供服务
- 同样与栈深度溢出，抛出StackOverflowError
- 动态栈扩展失败时，获取不到足够的内存，抛出 outOfMemoryError
#### 1.4、Java堆 java heap 存放对象实例
- 所有线程共享的一块内存区域
- 可以时物理上不连续的内存空间，但是要求逻辑上（计算机认为是）连续的内存空间
- 内存大小可设置可扩展的，也可以设置为固定的
    + 当前的主流虚拟机都是按照可扩展设置
    + -Xmx -Xms
    + Java堆没有完成对象创建，也无法扩展时，会抛出 outOfMemoryError
#### 1.5、方法区 method area 逻辑上的内存区域
- 线程共享的内存区域
- 用于存储已经被虚拟机加载的
    + 类型信息
    + 常量
    + 静态变量
    + 即时编译器编译后的代码缓存等数据--？
#### 1.6、运行时常量池 runtime constant pool
- class文件中的常量池表，存放编译其生成的字面量与符号引用
- 在类加载后，将这部分内容存放至方法区的运行时常量池中
- 但是并非只是编译期才产生，在运行时也可以将新的常量放入池中，如调用String.intern()方法
- 当常量池无法申请到内存时也会抛出outOfMemoryError
#### 1.7、直接内存 direct memory
- 被频繁引用
- 也会触发outOfMemoryError异常
- 参考NIO中的new input/output
- 通过native方法直接分配堆外内存，通过存储在Java堆中的directByteBuffer对象作为这块内存的引用进行操作
- 忽略直接内存的大小，会出现直接内存+Java堆内存 大于 机器的物理内存，导致outOfMemoryError异常
    