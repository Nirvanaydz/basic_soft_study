### 二、Java堆中的对象分配，布局和访问
#### 1.1、对象的创建 仅讨论new方法创建的过程，不考虑复制和序列化创建的对象，不考虑数组和class对象
- 如何创建
    + 类加载阶段，检查时，收到new指令，会通过这个指令的参数先去常量池中定位类的符号引用，若没有定位到，必须先完成类的加载
    + 为新生对象分配内存，把一块确定大小的内存块从堆中分配出来
        - 绝对规整的堆中： 已分配空间 ｜ 指针 ｜ 未分配空间
            + 挪动指针，移动需要分配的内存大小的距离，完成内存的分配。指针碰撞 bump the pointer
        - 不规整的堆：已分配空间和未分配空间交错在一起，维护一个空闲列表，记录未被使用的空间
            + 通过空闲列表中找到合适的位置，给对象分配内存 free list
        - 使用的垃圾收集器决定了一个堆是不是规整的
            + compact 标记整理，规整的
            + serial、parNew等新生代收集器就是使用的标记-复制-整理的方式
            + cms 标记清除，sweep 不规整的
    + 多线程申请对象的创建时，需要考虑内存分配的安全
        - 解决方式
        - 使用cas操作，对分配空间的动作进行同步，保证原子性
        - 对每一个线程预先分配一小块内存，将内存的分配动作按照线程划分在不同的区域，本地线程线程分配缓冲（thread local allocation buffer）
        - 是否使用TLAB设置 -XX:+/-UseTLAB
    + Java虚拟机对分配的内存空间初始化
        - 将内存空间（不包含对象头）都初始化为0
        - 保证对象实例在Java代码中可以不赋值使用
    + Java虚拟机对对象进行必要的设置--设置对象头
        - 对象是哪个类的实例
        - 如何找到类的元数据信息
        - 对象的hash码值（延后至真正调用对象的hashCode计算）
        - 对象的GC分代年龄等信息
    + 完成对象头的设置后
        - Java虚拟机认为对象已经设置完成了
        - 但是对于Java程序来说，一个对象的创建才刚刚开始--调用构造函数
        - 一般来说，new指令后会跟着一条init<>指令，对象会进行初始化创建
#### 1.2、对象的内存布局 【header｜instance data｜padding】
- header
    + 存储对象自身运行时的数据（32位机器使用32个比特，64位机器占用64个比特）
        - hash码值
        - GC年龄分代
        - 锁状态标识符
        - 线程持有的锁
        - 偏向锁的ID
        - 偏向时间戳
    + 类型指针-->指向类型元数据的指针，通过这个指针可以确定这个对象时哪个类的实例
        - 非必需存在？
        - 若是一个数组
            + 数组长度确定时，对象头中还会记录数组长度的数据
            + 数组长度不确定时，无法通过元数据信息确定数组的大小
- Java的对象头中存储详细简介
    + synchronized使用的锁时存储在对象头中的
    + 对象头
        - 对象不是一个数组时
            + mark word -- 存储对象的hashcode和锁信息
            + class metadata address -- 存储 到对象类型数据 的指针
        - 对象是一个数组时
            + 多出一个存储
            + array length -- 数组的长度
    + 无锁状态：
        - 32位： 对象的hashcode（25bit）｜对象的分代年龄（4bit）｜是否是偏向锁-0（1bit）｜锁标志位-01（2bit）
        - 64为： unused（24bit）｜对象的hashcode（31bit）｜cms-free（1bit）｜对象的分代年龄（4bit）｜是否是偏向锁-0（1bit）｜锁标志位-01（2bit）
    + 偏向锁状态：
        - 32位： 线程id+epoch｜分代年龄｜是否偏向锁-1｜锁标志位-01
        - 64位： threadId（54bit）+epoch（2bit）｜cms-free｜分代年龄｜是否偏向锁-1｜锁标志位-01
    + 轻量级锁：
        - 32位：指向栈中锁记录的指针｜锁标志位-00
    + 重量级锁：
        - 32位：指向互斥量（重量级锁）的指针｜锁标志位-10
    + gc标记时：空｜锁标志位-11
- instance data
    + 程序代码中定义的各种类型字段
    + 子类中定义的字段
    + 父类中定义的字段
    + 存储的顺序受jvm分配策略参数 -XX:FieldsAllocationStyle 和 字段在Java源码中定义的顺序影响
    + Java源码中定义的顺序 long/double-->int-->short/char-->byte/boolean-->oops
    + 相同的长度字段总是被分配到一起存放
        - 在满足这个规则的情况下，父类定义的变量会在子类之前出现
        - 也有存在，子类中较窄的变量也允许插入父类变量的空隙之中，以节约一定的空间
- padding
    + 填充对象，保证任何对象的大小都是8的倍数
#### 1.3、如何定位一个对象
- 如何找到创建好的对象
- 通过jvm stack中的栈帧中的reference数据来操作堆上的具体的对象
- 句柄式访问 在Java堆中划分一块内存区域，作为句柄池
    - reference对象存储对象的句柄地址，句柄中包含了对象的实例数据指针，这些指针指向 实例池或者方法区中的对象实例
    - 优势：reference中存储的是稳定的句柄地址，对象被移动只改变句柄池中的实例数据指针
- 直接指针访问
    - reference对象中直接存储对象的地址
    - 优势：速度快，一次开销就可以找到对象，hotSpot使用的就是指针访问
