### 三、Java中的垃圾回收器 garbage collection
#### 1.1、需要完成的三件事情
+ 存在与jvm线程调用栈，本地方法调用栈，程序计数器中的内存，是随着线程同生共死的，不涉及回收
+ 只需要回收Java heap和 method area中的内存
+ 哪些内存对象需要回收，对象已死如何判断？
+ 什么时候回收
+ 如何回收
#### 1.2、如何判断一个对象需要回收
- 判断对象的生死 dead alive
    + 引用计数法 reference counting
        - 有引用处+1，引用失效-1
        - 计数器为0时代表对象已死
        - 劣势：循环引用的两个空对象，引用计数法很难处理这种情况
        - hotspot不是使用的引用计数法
    + 可达性算法 reachability analysis
        - 可达至什么地方：GC ROOTS
            + 虚拟机栈中引用的对象
                - 局部变量
                - 参数
                - 临时变量
            + 方法区中类静态属性引用的对象，如：Java类的引用类型静态变量
            + 方法区中常量的引用对象，如字符串常量池（string table）中的引用
            + 本地方法栈JNI中引用的对象
            + 虚拟机内部引用
                - 基础数据类型对应的class对象
                - 常驻的异常 NullPointException，outOfMemoryError
                - 系统类加载器
            + 被同步锁持有的对象
            + 反映Java虚拟机内部情况的JMXBean，JVMTI中注册的毁掉、本地代码缓存等
        - 当一个对象检索引用树的时候，无法发到根结点，认为对象需要被回收
    + reference类是什么
        - reference类型的数据中存储的数值代表一块内存的起始位置，代表了某个内存或者对象的引用
        - 分类
            + strongLy reference    强引用关系还存在时，垃圾回收器就不会回收掉这个对象
            + soft reference        非必需的对象，在系统快要发生内存溢出时，会对此对象进行二次回收，若回收后还是内存不足，就会抛出内存溢出的异常
            + weak reference        只能存活到下一次垃圾回收开始之前，即下一次垃圾回收时会讲存在的weak引用都回收掉
            + phantom reference     唯一的目的：为了在这个对象被系统回收时收到一个系统的通知
    + 一个对象的真正死亡
        - 当一个对象被判断为不可达时，可以完成自我救赎
        - 首先当对象被判断为不可达时，标记这个对象
        - 筛选此对象是否有必要执行finalize方法，以下两种情况认为没有必要执行
            + 此对象没有重写object对象的finalize方法
            + 重写过了，但是finalize方法已经被调用过了
            + 可以理解为，即重写了finalize方法，且未被调用过时，可以自我救赎
        - 会将需要执行finalize方法的对象放入F-Queen队列中
        - 自我拯救：在finalize方法中，重新将自己指向一个根对象，可以完成自我救赎，但是只有一次机会，若下次救赎时发现已经救赎过了，则会被回收
    + 在方法区中的回收 废弃的变量和不再使用的类型
        - 废弃的常量
            + 理解成，这个常量之前存在常量池中，但是经过一段时间，垃圾回收时，恰好没有对象指向这个变量，那么就会被回收
        - 不再使用的类型的回收
            + 该类的所有实例在堆中都不存在（该类及其派生的子类）
            + 该类的类加载器被回收了
            + 该类对应的class对象没有在任何地方被引用，无法通过反射访问该类的方法