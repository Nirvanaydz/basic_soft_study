### 三、Java中的垃圾回收器 garbage collection 垃圾收集算法
#### 1.1、垃圾收集算法的基础和分类
- 分代回收假说 generational collection
    + weak generational hypothesis 绝大多数对象都是朝生夕灭的
    + strong generational hypothesis 熬过多次垃圾回收的对象，就越难以消亡
- 关注：难以消亡的对象
- 划分区域后GC收集器可以回收某一个或者某些区域
- 使用 标记-清除 ｜ 标记-复制 ｜ 标记-整理 等算法
- 处理跨代引用的问题
    + 产生：新生代中的对象可能被老年代中的对象引用，反之亦然
    + 回收时可能需要扫描整个老年代，减少扫描的范围可以优化跨代引用的问题
        - 处理方式：在新生代中维护一个全局的数据集--remember set，标记老年代中那些内存块存在跨代引用，在minor gc时可以只扫描这段集合，判断是否存在引用
- 名词解释
    + partial gc 不完整的收集Java heap
        - mirror/young gc   针对新生代的回收
        - major/old gc      针对老年代的回收
        - mixed gc          针对整个新生代和部分老年代的回收，仅G1支持
    + full gc   收集整个java heap 和 method area
#### 1.2、回收算法
- mark-sweep 标记清除 可使用和未使用的内存块交错在一起
    + 第一步：标记要回收的内存块
    + 第二步：回收标记了的内存块
    + 存在问题：
        - 大量数据要回收时，进行大量的标记和清除操作，回收不稳定
        - 产生很多的内存碎片
- mark-copy 标记复制    只存在使用区域和未使用区域
    + 将内存分为两块
    + 回收时将使用的区域中存活的对象复制到未使用的区域，将已使用的区域全量清除掉
    + 存在问题：
        - 存在大量的对象时，有很大的复制开销
        - 浪费内存，有进一半的内存未使用
    + 优化： serial，parNew等新生代回收器就是使用的这种方式
        - 较大的eden空间，较小的两块survivor空间
        - 每次分配对象时，只使用eden和一块survivor区域
        - 回收时，将eden区和使用中的s区的对象，存活的都拷贝到未使用的s区中
        - 当拷贝的对象过多时，需要使用到老年代的担保区间，handle promotion
            + 可以理解成银行贷款的担保人
- mark-compact
    + 标记清除的差异，存在对象的移动
    + 移动对象的利弊
        - 优点：移动对象是一个整理的过程，让可使用的内存区域连续，提高代码的效率
        - 缺点：存活对象过多时，整理对象，需要修改待整理对象的引用指针，stw，停止用户进程
    + 使用实例
        - parallel scavenge收集器
        - cms收集器
            + 多数情况下使用标记清除，容忍暂时的内存碎片
            + 当内存的分配无法满足时，再采用标记整理的方式收集一次，以获取规整的内存空间
