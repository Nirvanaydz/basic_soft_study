### 1、如何定义一个线程并启动
- extends thread/implements runnable
- 调用thread对象的start()方法是告诉系统安排一个时间来调用其run方法
- 有一个thread的构造函数：new Thread(Runnable target)需要关注
### 2、存在共享变量时，使用synchronized关键字将指定操作代码段加锁
### 3、currentThread()方法可以返回当前代码正在被哪个线程调用
### 4、isAlive()方法校验线程是否处于活跃状态
- 什么是活跃状态：线程处于正在运行或者准备开始运行的状态
### 5、sleep()方法，使当前线程暂停执行，不释放锁
### 6、getId()获取线程的唯一标识
### 7、interrupt()|interrupted()|isInterrupted()
- interrupt()：仅仅是在当前线程中打了一个停止标识
- interrupted()：运行此方法的线程是否已经中断，并且将状态标志清除为false
    + 下次再调用此方法时返回false
- isInterrupted()：测试线程thread对象是否已经是中断状态，但不清除状态标志
- 使用异常法结束线程的代码执行，在调用interrupted方法后，抛出异常（推荐使用）
- 使用异常法结束线程的代码执行，在调用interrupted方法后，使用return
- 在线程sleep时停止某一线程，会进入catch语句，抛出InterruptedException异常，并清除线程的停止状态值
### 8、使用stop()方法暴力停止线程
- 抛出ThreadDeath异常，不需要显式地捕捉
- 会对锁定的对象进行解锁，造成数据的不一致
### 9、resume/suspend/yield/setPriority
### 10、关于synchronized关键字的一些说明
- 在一个synchronized方法快内部调用其他的synchronized方法块是永远可以得到锁的，其实就是锁的连续占有
- 子类也可以通过上述方式调用父类的同步方法
- 在抛出异常后，synchronized关键字持有的锁释放
- override重写synchronized修饰的方法，也需要加上synchronized关键字，同步不能继承
### 11、关于volatile关键字的一些说明
- volatile保证的是共享变量的可见性
- 不能保证原子性：【在进行共享变量的运算操作时无法保证原子性】
    + 共享变量在线程内存中的操作步骤
        - read和load阶段：从主内存中复制并加载变量
        - use和asign阶段：操作和赋值阶段
        - store和write阶段：保存并同步回写至主内存
    + 其中load，use，assign阶段不是原子性的操作，在执行这些操作时，共享变量会被其他的工作线程修改
    + 解决这一问题的关键就是使用原子类【保证运算操作的原子性】进行操作
        - 需要注意的是原子类只是解决了共享变量原子性的操作，而不是解决了与其相关代码的同步性问题
        - 如遇到同步性问题还是需要使用锁的机制实现的
### 12、什么是等待/通知机制
- 使用wait，notify实现线程间的通信
- 首先注意注意，使用wait和notify方法都需要获取到该对象的对象级别的锁，即这两个方法都需要在同步代码中使用
    否则会抛出异常，IllegalMonitorStateException（一个runtimeException）
- wait方法执行后，当前线程释放掉持有的锁
- notify方法执行后，通知那些需要此锁的线程，如果存在多个线程竞争，则需要线程规划器随机选择一个呈wait状态的线程，
    在执行notify方法的线程执行完成后，才会去执行被选中的那个线程去执行，而不是立即执行
- wait立即释放对象锁，notify在线程执行完成后释放锁，notify只会唤醒一个wait状态中的线程，唤醒全部需要使用notifyAll
### 13、什么是join
- join的调用：使所属线程对象正常执行run方法中的任务，使当前线程无限期的阻塞，等待调用join方法的线程执行完成后再
    执行原有线程的代码
- join(long)在内部使用wait(long)方法来实现，所以会释放掉持有的锁，但是sleep(long)不会
### 14、reentrantLock，和condition的使用
- reentrantLock的lock和unlock就是synchronized关键字使用
- condition的获取使用reentrantLock的newCondition()方法获取
- 使用condition的await和signal方法时需要使用lock.lock()方法获取同步监视器
- 可以对一个reentrantLock使用多个condition来完成多个线程的控制
- 一般使用标识和lock的condition配合
- 一些基本方法：
    + int getHoldCount()：查询当前线程调用lock方法的次数
    + int getQueueLength()：查询等待此锁释放的线程的个数
    + int getWaitQueueLength(condition)：查询

