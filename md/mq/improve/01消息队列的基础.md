### 一、消息队列的使用场景

- 异步处理
- 流量控制
- 服务解耦

### 二、一个可靠的消息队列有什么特性，如何选择

- 消息的可靠传递
- 支持集群配置，保证可用性
- 性能开销要好

### 三、简单介绍几种消息队列

- rabbitMQ
    + 在producer和queue之间增加了exchange模块，通过路由规则将消息分发到不同的队列中
    + 对消息的堆积使用的不是很好
    + 性能较其他的消息队列较差，在十几万的qps
    + 编程语言冷门，定制化修改不方便
    + 消息模型
        - 严格遵循队列的设计模式
        - 使用exchange交换机实现发布订阅的方式
- rocketMQ
    + 品学兼优的中国学生
    + 几十万的qps
    + 较好的响应延时
    + 源代码易读，可定制
    + producer/consumer
    + broker--topic--n个队列对应给n个consumer使用，队列中存储偏移量来确认消费位置
- kafka
    + 2000w的qps
    + 异步批处理带来消息的等待，每秒钟的消息不多时，不建议使用kafka
    + kafka和rocket一直，只是queue变成了partition

### 四、保证消息的不丢失和重复消费

- 我们可以利用消息队列的有序性来验证是否有消息丢失， 在 Producer 端，我们给每个发出的消息附加一个连续递增的序号， 然后在 Consumer 端来检查这个序号的连续性
- kafka或者rocketMQ这样的消息队列，不保证topic的有序性，需要在每个分区单独检测消息的有序性
- 做到consumer和分区数量一致，做到与分区一一对应，可以较为方便的检测序号的连续性
- 生产阶段的保证：由producer向broker发送信息，使用确认响应来保证消息发送的成功
- 存储阶段的保证：在消息存储至磁盘或者向其他节点发送信息时，会出现宕机的情况
    + 单节点，保证写入磁盘后再发送确认响应
    + 多节点，确认发送到两个以上的节点后再发送给producer确认响应
- 消费阶段的保证：不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认
- 重复消费
    + MQTT协议：
        - at most once/at least once/exactly once
        - 至少一次是主流消息中间件的通用协议
        - at least once + 幂等 = exactly once
        - 使用数据库唯一约束
        - 为更新数据设置前置条件
        - 记录检查，在执行此操作是，查询是否已经执行过此操作，分布式系统中可以使用分布式锁或者事务实现

### 五、消息积压的处理

- 生产端
    + 准备数据和序列化，构造请求的过程
    + 发送消息和响应在网络中的耗时
    + broker处理消息的时延
- 消费端
    + 保证consumer和partition一致
    + 实际消费都是单线程的