### 四、redis的高可靠性-redis中的数据持久化

#### 1.1、append only file AOF

- 写后日志
    + 先执行命令写内存
    + 记录每一条命令，以文本的形式保存到磁盘中
    + 只有当命令执行成功，才会记录到日志中
    + 三种命令执行完后写回磁盘的策略
        - always：同步写回策略，每个写命令执行完，立即同步地将日志写回磁盘
        - everySec：每秒写回，将日志写到aof文件内存缓冲区，每隔一秒把缓冲区的内容写入磁盘
        - no：操作系统控制写回，每个写命令执行完，只是先把日志写到aof文件的内存缓冲区，何时写回磁盘由操作系统确定
    + 三种写回方式-都回存在一定的宕机后数据的丢失
        - 同步写回基本可以做到不丢失数据，但是每个写命令之后都有一个写回磁盘的慢速落盘操作，不可避免的影响主线程的性能
        - 操作系统控制，落盘时机已经不在redis手中，可能会丢失大量的数据
        - 每秒写回，是同步写回和操作系统控制写回的折中，即保证性能的同时，也保证数据丢失只会在上一秒中产生的会丢失
    + aof重写机制
        - 在通过日志恢复时，会依据数据库的现状创建一个新的aof文件
        - 创建时，会将多条与同一个key相关的操作变为一个，多变一，文件就变小了
        - 重写时会阻塞主线程吗？
            + 一个拷贝，两处日志
            + 一个拷贝：每次执行重写时，主线程fork后台的bgrewriteaof子线程
                - 将主线程的内存拷贝一份给bgrewriteof子线程，包含了数据库的最新数据
                - 子线程在不影响主线程的情况下，逐一把拷贝的数据写成操作，记录入重写日志
            + 两处日志
                - 正在使用的aof日志
                - 新的aof重写日志
                  ![](aof非阻塞重写过程.png)

#### 1.2、redis database RDB 内存快照

- 内存快照
- 记录的是某一个时刻的数据
- 在做数据恢复时，直接把rdb文件读入内存，很快地完成恢复
    + 哪些数据做快照 拍照片取景
    + 快照时的数据还能被增删改吗 拍照片时，提示人员不用晃动
- 如何快照
    + 首先redis使用的时全量快照，将所有内存中的数据都记录到磁盘中
    + 快照指令
        - save：在主线程中执行，会导致阻塞
        - bgsave：创建子线程，专门用于写入rdb文件，避免阻塞主线程，这也是redis rdb文件生成的默认配置
    + 快照时，被快照的数据发生变化怎么处理-写时复制 copy-on-write
        - 主线程fork出子线程进行bgsave，fork的好处就是子线程可以共享主线程的内存
        - 在主线程中刚刚fork出的内存中，有某一个数据发生变化时，内存中会产生一个此数据的新副本
        - 此数据保持不变，仍然给bgsave子线程快照使用
        - 这样，即保证了快照，某一时刻数据的稳定，也不影响主线程对于数据的修改
          ![](写时复制机制保证快照期间数据可修改.jpeg)
    + 快照的时机是什么
        - 频繁地执行快照
            + 较大的磁盘压力，多个快照竞争有限的磁盘带宽，前一个没做完，后一个又来了，容易造成恶性循环
            + fork子线程的操作，会阻塞主线程，主线程内存越大，阻塞时间越长
        - 首次全量快照
        - 后续快照时支队修改的数据进行快照记录，避免每次全量快照的开销
        - redis4.0中提出混合使用aof日志和内存快照的方法
            + 按照一定频率执行快照
            + 两次快照之间，使用aof日志记录这期间的所有命令操作

### 五、redis的高可靠性-redis中的数据备份

- redis的读写分离操作
    + 读操作，主库和从库都可以执行
    + 写操作，只有主库可以执行，主库执行后发送给从库执行
    + 为什么会读写分离
        - 客户端对一个key进行多次修改时，如果随机发送，那么各个库之间的值是不同的
        - 若为了维护数据的相同，那么需要加锁和实例间协商修改，带来巨额的开销
- 主从库间数据的第一次同步：三个阶段
  ![](主从库第一次同步流程.png)
    + 相关指令
        - replicaof（redis5.0之前使用slaveog）
        - 在从实例中执行此命令：replicaof 172.16.19.3 6379
    + 建立连接，协商同步阶段
        - 从实例执行slaveof或者replicaof指令，发送psync指令给主库
        - psync {不知道主库的runId，所以发?} {-1代表第一次同步}
        - 从库和主库建立连接，并告诉主库即将进行同步
        - 主库确认回复后，主从库准备开始数据同步
        - FULLRESYNC {主库的runId} {复制进度offset}
    + 主库将所有数据同步给从库
        - 从库在收到数据后，在本地完成数据加载，将原来的数据先清空，然后加载全量rdb文件
        - 此过程依赖内存快照生成的RDB文件
        - 数据同步过程中，产生的新修改数据的操作，主库会有一个内存专门保存，称为 replication buffer -全量复制时主库的耗时操作
            + 生成RDB文件和传输RDB文件
            + 从库较多时，主库忙于fork子进程进行数据全量同步
            + 传输RDB文件会占用很大的网络带宽
        - 主从级联模式分担复制时的主库压力
            + 将主从模式改为主从从的模式
            + 原先时一个主库进行对外执行写同步操作，此时可以选取一些从库，将其与手动选择的从库建立级联关系
              ![](级联的主从从模式.png)
    + 主库发送新写命令给从库，发送repl buffer
        - 此过程使用的是基于长连接的命令传播
        - 若网络断连或阻塞如何处理，是需要考虑的问题

### 六、哨兵集群的使用模式

- 监控
    + 哨兵进程运行时，给所有的主从库发送PING命令。若出现某一PING失败的时候，哨兵将其标记为下线（主库或者从库下线）
    + 哨兵集群的主观下线和客观下线，一个哨兵可以标记主库主观下线（主观的认为主库失效了，存在误判）
    + 为了减少误判，会启动多个哨兵，同时去监控主从库，多个哨兵都标记为主观下线，则标记为客观下线，进行从新选主和通知
    + n个哨兵时，n/2 + 1个哨兵认为失败则主观下线
- 选主
    + 选主：zk选主等操作（在线状态，网络状态筛选掉一部分不符合要求的从库）
    + 优先级（手动配置，如内存大，网络快等）高的从库得分高
    + 和旧主库的同步进度最接近的从库得分高，从库会有个slave_repl_offset值记录当前的复制进度，以此作为判断
    + redis默认ID小的从库得分高
- 通知
    + 将新主库的消息发送给其他从库，让从库执行replicaof命令，建立连接，进行数据复制
    + 将新主库的信息通知客户端，让它们把请求操作发送到新主库上

### 七、切片/分片集群

- 数据切片
- 纵向扩展：提升单个redis实例的资源配置，增加磁盘容量，cpu等
- 横向扩展：横向增加redis实例的个数，进行集群分片
    + 如何分片数据
        - redis-cluster的hash槽位分属
        - 通过crc16算法hash，再对16384取模
        - 手动将数据槽位指定到分片集群中的某一个数据节点上，注意需要将16384个槽位都分配完否则redis集群无法工作
        - 各个实例会通知其他实例自己的hash槽位信息
        - 与客户端建立连接时，会通知给各个客户端，每个客户端就知道取值时和哪些服务端建立请求
        - 集群中槽位不是一成不变的，服务端的删除和增加，负载均衡时会对hash槽位重新分配，这些客户端都不会立刻知道，导致一定的数据信息不一致
        - 重定向机制，在发送读写操作时，实例中没有相应的数据，会给客户端一个新实例发送操作命令，命令中包含了新实例的访问地址，将此槽位的访问移动至新的实例
        - 重新移动数据时，有一个过程，在未完全数据迁移成功时，会给客户端一个ask标识，并让客户端访问旧实例获取未同步到新实例的数据