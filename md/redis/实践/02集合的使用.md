### redis中的集合类型
- > **TODO：查看redis中基础数据类型的源码**
- List（按插入时的顺序有序，新插入的数据都是在队头中的）
  + 底层数据结构-链表
  + LPUSH插入list队头
  + LRANGE查询某一范围的数据
- hash（基数统计）
- set（唯一值时）
- sorted set（按照元素的权重有序）

### 一、聚合统计时使用set集合

- 单独启动一个聚合从统计redis，做聚合统计
- 所有登录的用户数据，key(user:id),value(所有的登录id的信息)
- 某一天所有登录的用户数据，key(user:id:当天日期),value(当天所有的登录id的信息)
- 计算并集： SUNIONSTORE user:id user:id user:id:20200803
- 计算差集： SDIFFSTORE user:new user:id:20200804 user:id

### 二、排序统计使用sorted-set

- sorted-set按照权重排序
- 在后去最新评论时，我们先按照评论时间权重排序
- 获取时使用： ZRANGEBYSCORE comments N-9 N

### 三、二值状态统计，使用bitmap实现

- setbit uid:sign:3000:202008 2（offset） 1
- GETBIT uid:sign:3000:202008 2
- 统计次数： BITCOUNT uid:sign:3000:202008
- offset偏移位置从0开始计算
- 在统计 1 亿个用户连续 10 天的签到情况时，你可以把每天的日期作为 key， 每个 key 对应一个 1 亿位的 Bitmap，每一个 bit 对应一个用户当天的签到情况。 接下来，我们对 10 个 Bitmap
  做“与”操作，得到的结果也是一个 Bitmap。 在这个 Bitmap 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。 最后，我们可以用 BITCOUNT 统计下 Bitmap 中的 1 的个数，这就是连续签到 10
  天的用户总数了。 现在，我们可以计算一下记录了 10 天签到情况后的内存开销。 每天使用 1 个 1 亿位的 Bitmap，大约占 12MB 的内存（10^8/8/1024/1024）， 10 天的 Bitmap 的内存开销约为
  120MB，内存压力不算太大。 不过，在实际应用时，最好对 Bitmap 设置过期时间， 让 Redis 自动删除不再需要的签到记录，以节省内存开销。 所以，如果只需要统计数据的二值状态， 例如商品有没有、用户在不在等 ，就可以使用
  Bitmap，因为它只用一个 bit 位就能表示 0 或 1。在记录海量数据时，Bitmap 能够有效地节省内存空间。

### 四、基数统计，统计一个集合中不重复的元素个数

- 统计每一页面的unique user
- set
    + SADD page1:uv user1，最后统计某一页面存储的用户数据量
- hash
    + HSET page1:uv user1 1，每次存储的值都是一，最后统计key的数量
- redis提供了hyperLoglog用于统计基数的数据集合类型
    + 增加数据：PFADD page1:uv user1 user2 user3 user4 user5
    + 统计数据：PFCOUNT page1:uv
    + 存在一定的误差：误差率为0.81%
- 可以借鉴的数据方式
    + ![](数据类型.webp)